# it seems like this is significantly faster than the matlab function
# the other advantage: it's easier to run python directly on the cluster (vs matlab)

import time
import os
import sys
import numpy as np

def gen_dqmc_input_files(param_array, input_file_dir="in", output_file_dir="out", geom_template_path="square.geom_tpl",
						 use_geometry_file=0, do_tdm=0, nx=8, ny=8, nwarmup=5000, npass=50000, seed=0, nimag_slices=80,
						 nbin=200, nhist=1, ntry=0, tausk=10, north=5, nwrap=15, fixwrap=1, errrate=1e-2, difflim=1e-6):
	"""
	Generate input files_out and geometry files_out for quest-qmc_avg. If the DQMC code is compiled to the program dqmc_prog, you
	would need to run "./dqmc_prog test.in", where "test.in" is the file generated by this function.

	Run this on the same machine you intend to run the dqmc simulations.
	e.g., if you intend to run quest on Linux cluster, then run this file there as well.

	:param param_array: N x 4 array of input parameters. Each row represents a single run. First column are mu_ups,
	                    second gives temperatures, third interactions, and fourth mu_dns
	:param input_file_dir: path to save input files_out
	:param output_file_dir: path to save output files_out
	:param geom_template_path: file path giving geometry file template
	:param use_geometry_file: boolean determining whether or not geometry files_out will be generated. If geometry files_out are
	       generated, they contain some information that would otherwise be stored in the input files_out. Some of the quest-qmc_avg
	       programs (e.g. quest-qmc_avg/geom/geom) use the geometry files_out, and other seem to ignore them (e.g. quest-qmc_avg/test/test)
	:param do_tdm: do time dependent measurements or not. Does not have an effect on all quest-qmc_avg files_out.
	:param nx: number of sites in the x-direction
	:param ny: number of sites in the y-direction
	:param nwarmup: number of warmup passes
	:param npass: number of measurement passes
	:param seed: quest-qmc_avg generates a random seed if the seed value is given as 0.
	:param seed: quest-qmc_avg generates a random seed if the seed value is given as 0.
	:param nbin: number of bins. someone (Alexis of Tremblay group ?) claimed that nbin > 2*L is necessary.
	:param nhist: todo: what does this do?
	:param ntry: todo: what does this do?
	:param tausk: todo: what does this do?
	:param north: todo: what does this do?
	:param nwrap: todo: what does this do?
	:param fixwrap: todo: what does this do?
	:param errrate: todo: what does this do?
	:param difflim: todo: what does this do?
	:return:
	"""

	# check parameters
	# U = np.arange(0, 18, 2)
	# mu_up = np.arange(-8, 8.5, 0.5)
	# T = np.array([0.3, 0.5, 1, 3, 8])

	# create grid of points
	# Us, mu_ups, Ts = np.meshgrid(U, mu_up, T)

	# combine into stack of (mu, period_start, U) points
	# num_inputs = mu_ups.size
	# param_array = np.zeros([num_inputs, 3])
	# param_array[:, 0] = np.ravel(mu_ups)
	# param_array[:, 1] = np.ravel(Ts)
	# param_array[:, 2] = np.ravel(Us)

	# create input file dir
	if not os.path.isdir(input_file_dir):
		os.mkdir(input_file_dir)

	if not os.path.isdir(output_file_dir):
		os.mkdir(output_file_dir)

	# start timing
	start_time = time.time()

	numSeeds = 1
	num_inputs = param_array.shape[0]
	nfiles = num_inputs * numSeeds
	print "generating %.0f files_out..." % nfiles
	num = 1
	# sets = "abcdefghijklmnopqrstuvwxyz"
	# nset = 0 # start set
	# maxN = 1e10 # num per set
	# FullCount = 1 # start out number

	# read data for greating geometry file
	with open(geom_template_path, 'r') as fID:
		geomtext = fID.read()

	# loop over input parameters and create files_out
	for jj in range(0, num_inputs):
		U = param_array[jj, 2]
		temp = param_array[jj, 1]
		mu_up = param_array[jj, 0]
		mu_dn = param_array[jj, 3]
		# mu_dn = mu_up
		
		# create geometry file
		if use_geometry_file:
			geomfilename = "square_U%.1f.geom" % U
			geomfile_path = os.path.join(input_file_dir, geomfilename)

			if not os.path.isfile(geomfile_path):
				with open(geomfile_path, 'w+') as fID:
					fID.write(geomtext % (nx, ny, U))
			
		# write input file
		for i in range(0, numSeeds):
			# fname = "input%s%d.in" % (sets[nset], num)
			fname = "input%d.in" % num
			fpath = os.path.join(input_file_dir, fname)

			with open(fpath, 'wt') as fID:
				# fID.write("ofile  = out/output%.0f \n" % FullCount)
				# fID.write("ofile  = out/output%.0f \n" % num)
				ofile = os.path.join(output_file_dir, "output%.0f" % num)
				fID.write("ofile  = %s \n" % ofile)

				if use_geometry_file:
					fID.write("gfile  = in/%s\n\n" % geomfilename)

				# if np.mod(num, maxN)==0:
				# 	nset = nset + 1
				# 	num = 0

				fID.write("# ==========================\n")
				fID.write("# Hubbard model\n")
				fID.write("# ==========================\n")

				if not use_geometry_file:
					fID.write("sums = %d \n" % nx)
					fID.write("ny = %d \n" % ny)
					fID.write("U = %.5f \n" % U)
					fID.write("t_up = %.1f \n" % 1)
					fID.write("t_dn = %.1f \n" % 1)
					
				fID.write("mu_up = %.5f \n" % mu_up)
				fID.write("mu_dn = %.5f \n" % mu_dn)
				fID.write("L = %.0f \n" % nimag_slices)
				fID.write("dtau = %.5f \n" % (1 / (temp * nimag_slices)))
				fID.write("HSF = %.0f \n" % -1)
				fID.write("bcond  =  0.0, 0.0, 0.0\n")

				fID.write("# ==========================\n")
				fID.write("# Met's algorithm\n")
				fID.write("# ==========================\n")

				fID.write("nwarm = %.0f \n" % nwarmup)
				fID.write("npass = %.0f \n" % npass)
				fID.write("ntry = %.0f \n" % ntry)
				fID.write("tdm = %.0f \n\n" % do_tdm) # bool value
				fID.write("tausk = %.0f \n" % tausk)

				fID.write("# ==========================\n")
				fID.write("# Measurements\n")
				fID.write("# ==========================\n")
				fID.write("nbin = %.0f \n" % nbin)
				fID.write("nhist = %.0f \n" % nhist)
				# QUEST generates a random seed if seed is 0
				fID.write("seed = %.0f \n\n" % seed)

				fID.write("# ==========================\n")
				fID.write("# numerical\n")
				fID.write("# ==========================\n")

				fID.write("north = %.0f \n" % north)
				fID.write("nwrap = %.0f \n" % nwrap)
				fID.write("fixwrap = %.0f \n" % fixwrap)
				fID.write("errrate = %.3f \n" % errrate)
				fID.write("difflim = %.8f \n" % difflim)

				# FullCount = FullCount + 1
				num = num + 1

	end_time = time.time()
	total_time = end_time - start_time
	print "Ran %d files_out in %0.2f s" % (nfiles, total_time)
	print "%0.2f s / file" % (total_time / nfiles)

def create_mu_T_U_grid(mu, T, U):
	"""
	Create an N x 4 array of all parameters to run in QMC. Run every possible combination of mu, T, and U. Assume mu_dn = mu_up = mu

	:param mu: mu values
	:param T: temperature values
	:param U: U values
	:return:
	param_array: an N x 4 array of all the parameters to run. First column, mu_up, second temperature, third interaction, fourth mu_dn
	"""


	# create grid of points
	UU, mumu, TT = np.meshgrid(U, mu, T)

	# combine into stack of (mu_up, temp, U, mu_dn) points
	num_inputs = mumu.size
	param_array = np.zeros([num_inputs, 4])
	param_array[:, 0] = np.ravel(mumu)
	param_array[:, 1] = np.ravel(TT)
	param_array[:, 2] = np.ravel(UU)
	param_array[:, 3] = np.ravel(mumu)

	return param_array

def create_muup_mudn_T_U_grid(mu_up, mu_dn, T, U):
	"""
	Create an N x 4 array of all parameters to run in QMC. Run every possible combination of mu_up, mu_dn, T, and U

	:param mu: mu values
	:param T: temperature values
	:param U: U values
	:return:
	param_array: an N x 4 array of all the parameters to run. First column, mu_up, second temperature, third interaction, fourth mu_dn
	"""
	UU, muumuu, TT, mudmud = np.meshgrid(U, mu_up, T, mu_dn)
	num_inputs = muumuu.size
	param_array = np.zeros([num_inputs, 4])
	param_array[:, 0] = np.ravel(muumuu)
	param_array[:, 1] = np.ravel(TT)
	param_array[:, 2] = np.ravel(UU)
	param_array[:, 3] = np.ravel(mudmud)

	return param_array


if __name__=="__main__":

	# modify these parameters to change
	U = np.arange(0, 18, 2)
	mu = np.arange(-12, -8, 0.5)
	T = np.array([0.3, 0.5, 1, 3, 8])
	# U = np.array([-3])
	# mu = np.array([-8, 0, 8])
	# T = np.array([0.5, 1])

	param_array = create_mu_T_U_grid(mu, T, U)

	if len(sys.argv) == 1:
		# if recieve no arguments
		gen_dqmc_input_files(param_array)
	elif len(sys.argv) == 2:
		# if receive one argument
		gen_dqmc_input_files(param_array, input_file_dir=sys.argv[1])
	else:
		raise Exception("Received wrong number of argument in command line")

	


